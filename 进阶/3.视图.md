# 视图
视图是一种**虚拟存在的表**。视图中的数据**并不**在数据库中**实际存在**，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的
通俗地说，视图只保存了查询的 SQL 逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条 SQL 查询语句上

## 视图的作用
- 简单
视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些**被经常使用的查询**可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件
- 安全
MySQL 数据库最多只能授权到表，不能授权到数据库特定的行/列上。通过视图用户**只能查询和修改他们所见到的数据**（例如对于一个学生表，我们只想让用户看到学生的姓名，成绩，而不想让用户看到学生的身份证号，此时就可以使用视图）
- 数据独立
视图可以帮助用户屏蔽真实表结构变化带来的影响



## 视图的基本语法
- 创建视图
```sql
# 如果我们要替换某个视图，可以加上 OR REPLACE
CREATE [OR REPLACE] VIEW 视图名称[(列表名称)] AS SELECT语句 [WITH [CASCADED | LOCAL] CHECK OPTION]
```
- 查询视图
```sql
# 查看创建视图语句
SHOW CREATE VIEW 视图名称;
# 查看视图数据（和查表的语句类似）
SELECT * FROM 视图名称 WHERE 条件;
```
- 修改视图
```sql
# 第一种方法（OR REPLACE 一定要有）
CREATE OR REPLACE VIEW 视图名称[(列表名称)] AS SELECT语句 [WITH [CASCADED | LOCAL] CHECK OPTION];
# 第二种方法
ALTER VIEW 视图名称[(列表名称)] AS SELECT语句 [WITH [CASCADED | LOCAL] CHECK OPTION];
```
- 删除视图
```sql
DROP VIEW [IF EXISTS] 视图名称;
```

## 检查选项 cascaded
> #### 补充
> 我们可以往视图中**插入数据**，和向表中插入数据的语法类似。但是前面我们说过：视图是一张**虚拟存在的表**，并不实际存储数据。因此，数据是被插入到了**该视图对应的表中**

> #### 例子
> ```sql
> # 生成一个名为 s1 的视图，该视图基于表 tb1
> CREATE OR REPLACE VIEW s1 AS SELECT * FROM tb1 WHERE id <= 20;
> # 此时向 s1 中插入数据，实际上数据被插入到了 tb1 中
> INSERT INTO s1 (id, name) VALUES (10, 'Tom');
> ```

但是这会引出一个问题，如果插入的数据 id > 20，则该数据不会在视图中显示。为了避免这种情况的出现，我们就要用到 **CASCADED** 选项，如下所示
```sql
CREATE VIEW id_name_vi AS SELECT * FROM account WHERE id < 20 WITH CASCADED CHECK OPTION;
```

此时再插入下面这条语句：
```sql
INSERT INTO s1 (id, name) VALUES (30, 'Tom');
```
会出现报错：CHECK OPTION failed 'new_database.id_name_vi'。下面详细介绍视图中的检查选项

当使用 WITH CHECK OPTION 子句创建视图时，MySQL 会通过**视图**检查正在更改的每个行，例如插入、更新、删除，以**使其符合视图的定义**。<u>MySQL 允许**基于另一个视图创建视图**</u>，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，MySQL 提供了两个选项：CASCADED 和 LOCAL，默认为 CASCADED

下面我们来详细解释下划线的句子，在视图中，可能会出现这种情况：
```sql
CREATE VIEW v1 AS SELECT * FROM student_tb WHERE id <= 20;
# v2 是基于 v1 的
CREATE VIEW v2 AS SELECT * FROM v1 WHERE id >= 10 WITH CASCADED CHECK OPTION;
```

此时当我们操作 v2 时，不仅会检查操作是否满足 v2 的条件，**还会去检查是否满足 v1 中的条件**（即使创建 v1 时没有写 WITH CASCADED CHECK OPTION）

下面我们考虑一种更加复杂的情况：
```sql
CREATE VIEW v1 AS SELECT * FROM student_tb WHERE id <= 20;
# v2 是基于 v1 的
CREATE VIEW v2 AS SELECT * FROM v1 WHERE id >= 10 WITH CASCADED CHECK OPTION;
# v3 是基于 v2 的
CREATE VIEW v3 AS SELECT * FROM v2 WHERE id <= 15;
```

分析：v3 没有检查选项，所以插入数据时**不会检查 id <= 15**，但是由于 v3 是基于 v2 的，所以插入数据时**会检查 id >= 10**，又因为 v2 是基于 v1 的，所以插入数据时**会检查 id <= 20**

## 检查选项 LOCAL
考虑这种情况：
```sql
CREATE VIEW v1 AS SELECT * FROM student_tb WHERE id <= 20;
# v2 是基于 v1 的
CREATE VIEW v2 AS SELECT * FROM v1 WHERE id >= 10 WITH LOCAL CHECK OPTION;
# v3 是基于 v2 的
CREATE VIEW v3 AS SELECT * FROM v2 WHERE id <= 15;
```
分析：v3 没有检查选项，所以插入数据时**不会检查 id <= 15**，但是由于 v3 是基于 v2 的，所以插入数据时**会检查 id >= 10**，又因为 v2 是基于 v1 的，此时来到 v1，但是由于 v2 的检查选项是 LOCAL，且 v1 没有检查选项，所以插入数据时**不会检查 id <= 20**

> #### Tips——LOCAL 和 CASCADED 的差距
> - CASCADED 它会对所有它引用的父辈、祖父辈视图做**级联检查**（即使父辈，祖父辈视图中没有检查选项）
> - LOCAL 不会对所有它引用的父辈、祖父辈视图做**级联检查**，即如果父辈/祖父辈视图中没有检查选项，则**不会对条件进行检查**

## 视图的更新
要使视图可以更新，视图中的行与基础表中的行之间必须存在**一对一**的关系，如果视图中包含以下任何一项，则该视图不能更新
- 聚合函数或窗口函数（SUM(), MIN(), MAX(), COUNT()等）
- DISTINCT
- GROUP BY
- HAVING
- UNION 或者 UNION ALL