# 存储过程
存储过程是**事先经过编译并存储在数据库中的一段 SQL 语句的集合**，调用存储过程可以**简化开发人员的很多工作**，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的
存储过程思想上很简单，就是数据库 SQL 语言层面的**代码封装与重用**

存储过程的特点
- 封装和复用
- 可以接收参数，也可以返回数据
- 减少网络交互，效率提升

## 存储过程基本语法
> #### Tips
> 此处先不管参数列表和参数

- 创建
```sql
CREATE PROCEDURE 存储过程名称([参数列表])
BEGIN
    -- SQL 语句
END:
```
- 调用
```sql
CALL 存储过程名称([参数]);
```
- 查看
```sql
# 查询指定数据库的存储过程以及状态信息
SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = 指定数据库的名称;
# 查询某个存储过程的定义
SHOW CREATE PROCEDURE 存储过程名称;
```
- 删除
```sql
DROP PROCEDURE [IF EXISTS] 存储过程名称;
```

> #### Tips
> 在命令行中，执行创建存储过程的 SQL 时，需要通过关键字 DELIMITER 指定 SQL 语句的结束符（否则存储过程中也有分号，会导致语句提前结束）
> DELIMITER 的用法如下：
> ```sql
> # 指定 $$ 为 SQL 语句的结束符
> DELIMITER $$
> ```
>
> 然后就可以将存储过程的语句复制到命令行中了

## 变量
### 系统变量
系统变量由 **MySQL 服务器提供**，不是用户定义的，属于**服务器**层面，分为全局变量（GLOBAL，在所有会话中有效）、会话变量（SESSION，仅在当前会话中有效）

- 查看系统变量
```sql
# 查看所有系统变量
SHOW [SESSION | GLOBAL] VARIABLES;
# 可以通过 LIKE 模糊匹配方式查看变量
SHOW [SESSION | GLOBAL] VARIABLES LIKE '...';
# 查看指定变量的值
SELECT @@[SESSION | GLOBAL] 系统变量名;
```
如果不设置 SESSION 或 GLOBAL，则默认是 SESSION
- 设置系统变量
```sql
SET [SESSION | GLOBAL] 系统变量名 = 值;
# 这里必须用 @@，因为一个 @ 代表用户定义变量
SET @@[SESSION | GLOBAL] 系统变量名 = 值;
```
按照上面的方式修改，当 MySQL 服务器重启之后，系统变量的值会恢复为初始值。如果想实现永久修改，可以在 /etc/my.cnf 中配置

### 用户自定义变量
用户定义变量是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用 '@变量名' 使用即可。其作用域为**当前连接**
- 赋值（方法 1）
```sql
SET @变量名 = expr [,@var_name = expr]...;
SET @变量名 := expr [,@var_name = expr]...;
```
- 赋值（方法 2）
```sql
SELECT @变量名 := expr [,@var_name = expr]...;
# 把 SELECT 语句查询结果的值赋值给变量
SELECT 字段名 INTO @变量名 FROM 表名;
```

> #### Tips
> 由于 MySQL 中 '=' 既可以做赋值运算符，还可以做比较运算符，因此赋值时推荐使用 ':='

> #### 例子——自定义变量赋值
> ```sql
> SET @myname = 'liyi';
> SET @myage = 20;
> SET @mygender = 'male', @myhobby = 'coding';
> ```
- 使用
```sql
SELECT @变量名;
```

> #### Tips
> 如果我们使用了**未赋值的自定义变量**，**不会报错**，只不过获取到的值为 **NULL**

### 局部变量
局部变量是根据需要定义的在局部生效的变量，访问之前，需要 **DECLARE 声明**。可用作**存储过程内的局部变量和输入参数**，局部变量的范围是**在其内声明的 BEGIN ... END 块**

- 局部变量的声明
```sql
# 如果变量有默认值，则可以用 DEFAULT 设置默认值
# 变量类型是 INT, VARCHAR, CHAR 等
DECLARE 变量名 变量类型 [DEFAULT ...];
```
- 赋值
```sql
SET 变量名 = 值;
SET 变量名 := 值;
SELECT 字段名 INTO 变量名 FROM 表名;
```

## 参数
一共有 3 种参数：
- IN（默认）：该类参数作为**输入**，也就是需要调用时**所传入的值**
- OUT：该类参数作为**输出**，也就是该参数可以作为**返回值**
- INOUT：既可以作为输入参数，也可以作为输出参数

语法：
```sql
# 有了 OUT 参数，我们就可以不用 SELECT 展示结果了
CREATE PROCEDURE 存储过程名称([IN/OUT/INOUT 参数名 参数类型])
BEGIN
    -- SQL 语句
END;
```

> #### 例子——分数划分改造
> 修改前面的分数划分例子，把分数作为输入，判定结果作为输出并返回
> ```sql
> CREATE PROCEDURE p4(IN score INT, OUT res VARCHAR(10))
> BEGIN
>     IF score >= 85 THEN
>         SET res := 'Excellent';
>     ELSEIF score >= 60 THEN
>         SET res := 'Pass';
>     ELSE
>         SET res := 'Fail';
>     END IF;
> END;
>
> # 把结果存储在 result 变量中，并展示
> CALL p4(10, @result);
> SELECT @result;
> ```

## 分支条件
### IF 
语法
```sql
IF 条件1 THEN
    ...
ELSEIF 条件2 THEN
    ...
ELSE
    ...
END IF;
```

> #### 例子——分数划分
> ```sql
> CREATE PROCEDURE p3()
> BEGIN
>     DECLARE score INT DEFAULT 90;
>     DECLARE res VARCHAR(10);
>     IF score >= 85 THEN
>         SET res := 'Excellent';
>     ELSEIF score >= 60 THEN
>         SET res := 'Pass';
>     ELSE
>         SET res := 'Fail';
>     END IF;
>     # 用 SELECT 语句输出结果
>     SELECT res;
> END;
> ```

### CASE
此处的 CASE 语法和流程控制函数中的 CASE 语法类似
- 语法 1
```sql
CASE 变量
    WHEN 值1 THEN 语句1;
    ...
    ELSE 语句;
END CASE;
```
- 语法 2
```sql
CASE
    WHEN 条件1 THEN 语句1;
    ...
    ELSE 语句;
END CASE;
```

> #### 例子——月份所属的季度
> ```sql
> CREATE PROCEDURE p4(IN month INT, OUT res VARCHAR(10))
> BEGIN
>     CASE
>         WHEN month >= 1 AND month <= 3 THEN
>             SET res := '第一季度';
>         WHEN month >= 4 AND month <= 6 THEN
>             SET res := '第二季度';
>         WHEN month >= 7 AND month <= 9 THEN
>             SET res := '第三季度';
>         WHEN month >= 10 AND month <= 12 THEN
>             SET res := '第四季度';
>         ELSE
>             SET res := '输入月份有误';
>     END CASE;
> END;
> 
> CALL p4(1, @res);
> SELECT @res;
> ```

## 循环条件
### WHILE
语法
```sql
# 先判断条件，如果条件为 true，则执行逻辑，否则不执行逻辑
WHILE 条件 DO
    # SQL 逻辑
END WHILE;
```

> #### 例子——计算前 1 到 n 的和
> ```sql
> CREATE PROCEDURE p4(IN n INT, OUT res INT)
> BEGIN
>     # res 一定要初始化，不初始化的话结果就是 NULL
>     SET res := 0;
>     WHILE n > 0 DO
>         SET res := res + n;
>         SET n := n - 1;
>     END WHILE;
> END;
> 
> CALL p4(10, @myres);
> SELECT @myres; 
> ```

### REPEAT
WHILE 是满足条件则进入循环，REPEAT 是满足条件则**退出循环**（有点像 do-while，因为循环的第一次一定会执行）

语法
```sql
REPEAT
    # SQL 逻辑
    UNTIL 条件
END REPEAT;
```

### LOOP
LOOP 实现简单的循环，如果不在 SQL 语句中增加退出循环的条件，可以用其来实现简单的死循环——即 LOOP 语句本身**不能控制循环的退出**。因此 LOOP 需要配合以下两个语句使用：
- LEAVE：配合循环使用，**退出循环**
- ITERATE：必须用在循环中，作用是**跳过当前循环剩下的语句，直接进入下一次循环**

语法
```sql
# 一般来说，begin_label 和 end_label 要一致
[begin_label:] LOOP
    # SQL 逻辑
END LOOP [end_label];

LEAVE label;    # 退出指定标记的循环体
ITERATE label;  # 直接进入下一次循环
```

> #### 例子——计算从 1 到 n 的偶数之和
> ```sql
> CREATE PROCEDURE p5(IN n INT, OUT res INT)
> BEGIN
>     SET res := 0;
>     evensum: LOOP
>         IF n <= 0 THEN
>             LEAVE evensum;
>         END IF;
>         IF n % 2 != 0 THEN
>             SET n := n - 1;
>             ITERATE evensum;
>         END IF;
> 
>         SET res := res + n;
>         SET n := n - 1;
>     END LOOP evensum;
> END;
> 
> CALL p5(10, @myres);
> SELECT @myres;
> ```

## 游标
游标是用来**存储查询结果集**的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括：
- 游标的声明
```sql
# 把查询语句的结果用游标封装起来
DECLARE 游标名称 CURSOR FOR 查询语句;
```
- 打开游标（OPEN）
```sql
# 使用游标之前必须要打开游标
OPEN 游标名称;
```
- 获取游标记录（FETCH）
```sql
FETCH 游标名称 INTO 变量1, 变量2,...;
```
- 关闭游标（CLOSE）
```sql
CLOSE 游标名称;
```

> #### Tips——游标的实质
> 当我们用 SQL 语言从数据库中检索到数据后，结果存放在内存中的一块区域中，且检索到的数据往往是一个含有多个记录的集合。游标则充当**指针**的作用，允许用户**逐行地**访问这些记录，按照用户的意愿来显示或处理这些数据

> #### Tips——使用游标的小技巧
> 1. 游标的声明应该在普通变量的声明**之后**
> 2. 由于需要**逐行处理数据**，因此在使用 FETCH 语句时应该考虑使用 **WHILE 循环**

> #### 例子——筛选合适年龄的用户
> 根据传入的参数 uage，查询用户表 tb_user 中，所有的用户年龄小于等于 uage 的用户姓名和专业，并将用户的姓名和专业插入到所创建的一张新表中
> ```sql
> CREATE PROCEDURE p11(IN uage INT)
> BEGIN
>     DECLARE uname VARCHAR(100);
>     DECLARE upro VARCHAR(100);
>     DECLARE u_cursor CURSOR FOR SELECT name, profession FROM tb_user WHERE age <= uage;
>     
>     # 创建新表之前先丢弃原来的已经创建的表（如果有的话）
>     DROP TABLE IF EXISTS tb_user_pro;
>     CREATE TABLE IF NOT EXISTS tb_user_pro (
>         id INT PRIMARY KEY AUTO_INCREMENT,
>         name VARCHAR(100),
>         profession VARCHAR(100),
>     );
>
>     OPEN u_cursor;
>     WHILE TRUE DO
>         FETCH u_cursor INTO uname, upro;
>         INSERT INTO tb_user_pro VALUES (NULL, uname, upro);
>     END WHILE;
> END;
> ```

## 条件处理程序
根据前面的例子可知：游标中的循环一般以 WHILE TRUE 形式出现，因此**循环退出的时机**变成了一个重要的问题。如果不处理好这个问题，容易出现下面这种报错
```txt
[02000][1329] No data - zero rows fetched, selected or processed
```
此时说明数据都获取完了，但是还在 FETCH 数据（实际上，上面的例子就会出现这个报错）。为了解决这个问题，我们引入了**条件处理程序**

条件处理程序可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体语法为：
```sql
DECLARE handler_action HANDLER FOR condition_value1, .... statement;

# 其中 handler_action 有两种
# CONTINUE: 继续执行当前的程序
# EXIT: 终止执行当前程序

# condition_value 有四种
# SQLSTATE sqlstate_value: 状态码，例如 '02000'
# SQLWARNING: 所有以 01 开头的 SQLSTATE 代码的简写
# NOT FOUND: 所有以 02 开头的 SQLSTATE 代码的简写
# SQLEXCEPTION: 所有没有被 SQLWARNING 或 NOT FOUND 捕获的 SQLSTATE 代码的简写
```

因此改写上面的例子，有：
> #### 例子——优化 bug
> ```sql
> CREATE PROCEDURE p11(IN uage INT)
> BEGIN
>     DECLARE uname VARCHAR(100);
>     DECLARE upro VARCHAR(100);
>     DECLARE u_cursor CURSOR FOR SELECT name, profession FROM tb_user WHERE age <= uage;
>     # 修改的地方：增加错误处理
>     DECLARE EXIT HANDLER FOR NOT FOUND CLOSE u_cursor;
>     
>     # 创建新表之前先丢弃原来的已经创建的表（如果有的话）
>     DROP TABLE IF EXISTS tb_user_pro;
>     CREATE TABLE IF NOT EXISTS tb_user_pro (
>         id INT PRIMARY KEY AUTO_INCREMENT,
>         name VARCHAR(100),
>         profession VARCHAR(100),
>     );
>
>     OPEN u_cursor;
>     WHILE TRUE DO
>         FETCH u_cursor INTO uname, upro;
>         INSERT INTO tb_user_pro VALUES (NULL, uname, upro);
>     END WHILE;
> END;
> ```

## 存储函数
存储函数是**有返回值的存储过程**，存储函数的参数**只能是 IN 类型的**，具体语法如下：
```sql
CREATE FUNCTION 存储函数名称([参数列表])
RETURNS TYPE [characteristic...]
BEGIN
    # SQL 语句
    RETURN ...;
END;
```

其中 characteristic 可以有下面 3 种类型
- DETERMINISTIC：相同的输入参数总是产生相同的结果
- NO SQL：不包含 SQL 语句
- READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句

> #### Tips
> characteristic 是**一定要指定的**